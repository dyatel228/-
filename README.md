Блажко Иван ИТ-8

Постановка задачи: 

В файле даны n целых чисел, и здесь же указан путь их размещения в бинарном дереве виде двоичного кода (коды не повторяются). Построить двоичное дерево целых чисел, в котором путь по дереву определяется указанным двоичным кодом в этом листе (1 – переход к правому потомку, 0 - переход к левому потомку). В корень автоматически заносится значение 0. Учитывать ситуацию, когда дерево не может быть построено.

1. Класс Node (Узел дерева):

•  Назначение: Представляет один узел в бинарном дереве.
•  Структура данных:
  •  data: Содержит значение, хранящееся в узле (целое число).
  •  left: Указатель на левого потомка. Если левого потомка нет, содержит None.
  •  right: Указатель на правого потомка. Если правого потомка нет, содержит None.
  • count: Счетчик, показывающий, сколько раз данное значение встречается в узле (для обработки дубликатов).
•  Обоснование: Бинарное дерево - это структура данных, состоящая из узлов, соединенных связями. Каждый узел имеет данные и ссылки на другие узлы (потомки). None используется для обозначения отсутствия потомка. count добавляет возможность хранить одинаковые значения в дереве, просто увеличивая счетчик, а не создавая новый узел.

2. Класс Tree (Дерево):

•  Назначение: Представляет бинарное дерево целиком и содержит методы для работы с ним.
•  Структура данных:
  •  root: Указатель на корневой узел дерева.
•  Методы:
  •  __init__(self): Конструктор класса. Создает новый объект Tree и инициализирует root корневым узлом со значением 0. Корень всегда существует.
  •  insert(self, node, data, path, index=0): Вставляет новый узел с данными data в дерево, следуя по пути path. node - текущий узел, в котором идет поиск места для вставки. index отслеживает текущую позицию в строке path.
    *  Алгоритм вставки:
      1. Базовый случай (рекурсия): Если index достиг конца пути (path), значит, найдено место для вставки.
        *  Если в текущем узле значение отличается от 0, значит, по этому пути уже есть другое число, выбрасываем исключение.
        *  Иначе, записываем data в node.data.
      2. Рекурсивный шаг:
        *  Берем текущий символ direction из пути path (либо '0', либо '1').
        *  Если direction равен '0', переходим к левому потомку. Если левого потомка не существует, создаем новый узел Node и присваиваем его. Затем рекурсивно вызываем insert для левого потомка.
        *  Если direction равен '1', делаем то же самое для правого потомка.
        *  Если direction не равен ни '0', ни '1', выбрасываем исключение, т.к. путь некорректен.
  •  check_missing_nodes(self, data): Проверяет, не пропущены ли промежуточные узлы в путях, указанных в данных.
    *  Алгоритм проверки:
      1. Извлекает все пути из входных данных data.
      2. Сортирует список путей, чтобы более короткие пути шли раньше более длинных (это важно для логики проверки). Реализована сортировка без использования встроенной функции.
      3. Перебирает все пары путей, где второй путь длиннее первого.
      4. Если второй путь начинается с первого, то второй путь является потомком первого. Нужно проверить, существует ли узел, представляющий непосредственного потомка первого пути.
      5. Вычисляет путь к этому непосредственному потомку (missing_path).
      6. Если missing_path отсутствует в списке путей, значит, узел пропущен, и выбрасывается исключение.

3. Функция read_excel_data(file_path):

•  Назначение: Читает данные из Excel-файла, проверяет их корректность и возвращает список кортежей (число, путь).
•  Алгоритм:
  1. Использует pandas для чтения Excel-файла в DataFrame.
  2. Перебирает строки DataFrame.
  3. Для каждой строки:
    *  Извлекает число и путь из столбцов.
    *  Проверяет, что число можно преобразовать в целое число.
    *  Проверяет, что число не содержит ведущих нулей.
    *  Проверяет, что путь состоит только из символов '0' и '1'.
    *  Добавляет кортеж (число, путь) в список data.
  4. Возвращает список data.
•  Типы данных:
  •  file_path: строка (путь к файлу).
  •  df: pandas.DataFrame (таблица данных).
  •  data: список кортежей (целое число, строка).
•  Обоснование: Функция инкапсулирует логику чтения и валидации данных, что делает основной код более чистым. Использование pandas упрощает чтение Excel-файла. DataFrame позволяет удобно работать с табличными данными.

4. Функция visualize_tree(root):

•  Назначение: Визуализирует бинарное дерево с помощью библиотеки networkx и matplotlib.
•  Алгоритм:
  1. Создает граф networkx.
  2. Использует обход дерева в ширину (BFS) для создания координат узлов для визуализации.
  3. Для каждого узла создает метку, содержащую значение узла и счетчик дубликатов (если есть).
  4. Добавляет узлы и ребра в граф.
  5. Использует matplotlib для отрисовки графа с заданными координатами и метками.
•  Обоснование: Визуализация позволяет наглядно увидеть структуру дерева и проверить правильность его построения. networkx предоставляет удобные инструменты для работы с графами, а matplotlib - для их отрисовки.

5. Основной блок кода
•  Алгоритм:
  1. Читает данные из Excel-файла с помощью read_excel_data.
  2. Создает экземпляр класса Tree.
  3. Проверяет наличие пропущенных узлов с помощью tree.check_missing_nodes.
  4. Если проверка прошла успешно, вставляет узлы в дерево с помощью tree.insert.
  5. Визуализирует дерево с помощью visualize_tree.
•  Обработка исключений:
  •  FileNotFoundError: Перехватывает исключение, если файл tree_data.xlsx не найден.
  • ValueError: Перехватывает исключения, возникающие при чтении данных, проверке корректности данных, при вставке узлов (например, при конфликте путей) или при обнаружении пропущенных узлов.

Обоснование общих решений:

•  Бинарное дерево: Выбрано, потому что пути в данных бинарные (состоят из '0' и '1'). Это позволяет эффективно организовывать данные в иерархическую структуру.
•  Рекурсия в insert: Рекурсия естественно подходит для обхода древовидных структур.
• Обработка исключений: Важна для обеспечения надежности программы. Позволяет корректно обрабатывать ошибки, возникающие при чтении данных, проверке их корректности или при работе с деревом.
• Использование pandas, networkx и matplotlib: Эти библиотеки использовались для чтения данных из excel-файла (pandas) и наглядного примера построения двоичного дерева (matplotlib и networkx)
•  Строковый тип данных для путей: Пути состоят из последовательности символов '0' и '1', поэтому строковый тип является наиболее подходящим для их представления.

Обработка исключений в коде организована следующим образом:

•  read_excel_data: В этой функции ловим ошибки, связанные с чтением данных из Excel-файла (например, файл не найден или имеет неправильный формат). Это позволяет сразу понять, если проблема с входными данными.
•  check_missing_nodes: Эта функция проверяет, все ли узлы есть в дереве.
•  Основной блок: Здесь ищем все остальные возможные ошибки, которые не были обработаны в других местах (например, ошибки при создании дерева или его визуализации). Это нужно для того, чтобы программа не завершилась внезапно, а показала пользователю сообщение об ошибке.
# -
